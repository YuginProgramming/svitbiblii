import Epub from "epub";
import path from "path";
import { fileURLToPath } from "url";
import AdmZip from "adm-zip";
import xml2js from "xml2js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let epubInstance = null;

/**
 * Load EPUB file once and reuse the instance
 */
async function loadEpub() {
  if (!epubInstance) {
    const epubPath = path.join(__dirname, "book.epub");
    epubInstance = new Epub(epubPath);

    await new Promise((resolve, reject) => {
      epubInstance.on("error", (err) => reject(new Error("Failed to load book: " + err.message)));
      epubInstance.on("end", resolve);
      epubInstance.parse();
    });
  }
  return epubInstance;
}

/**
 * Get plain text of specific chapter by index
 */
export async function getChapterText(index) {
  const epub = await loadEpub();

  if (!epub.flow || index < 0 || index >= epub.flow.length) {
    throw new Error(`Chapter index ${index} is out of range`);
  }

  const chapterId = epub.flow[index].id;

  return new Promise((resolve, reject) => {
    epub.getChapter(chapterId, (err, html) => {
      if (err) return reject(new Error("Error reading chapter: " + err.message));

      const plainText = html
        .replace(/<br\s*\/?>/gi, "\n")
        .replace(/<\/p>/gi, "\n")
        .replace(/<[^>]+>/g, "")
        .replace(/\n\s*\n\s*\n+/g, "\n\n")
        .trim();

      resolve(plainText || "No text found.");
    });
  });
}

/**
 * Get formatted chapter preview (title + first 3 verses)
 */
export async function getChapterPreview(index) {
  const fullText = await getChapterText(index);
  
  if (fullText === "No text found.") {
    return { title: "", content: "No text found.", hasMore: false };
  }

  // Split into lines
  const lines = fullText.split('\n').filter(line => line.trim());
  
  // Extract title and subtitle
  let title = "";
  let subtitle = "";
  let contentStartIndex = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Look for chapter number (Розділ X)
    if (line.includes("Розділ")) {
      title = line;
      contentStartIndex = i + 1;
      
      // Check if next line is a subtitle (not a verse number)
      if (i + 1 < lines.length) {
        const nextLine = lines[i + 1].trim();
        if (nextLine && !/^\d+/.test(nextLine) && !nextLine.includes("Розділ")) {
          subtitle = nextLine;
          contentStartIndex = i + 2;
        }
      }
      break;
    } else if (i === 0 && !title) {
      // Fallback: use first line as title
      title = line;
      contentStartIndex = i + 1;
    }
  }
  
  // Combine title and subtitle
  const fullTitle = subtitle ? `${title}\n${subtitle}` : title;
  
  // Extract first 3 verses
  const contentLines = lines.slice(contentStartIndex);
  const verses = [];
  let verseCount = 0;
  
  for (const line of contentLines) {
    const trimmedLine = line.trim();
    if (trimmedLine && /^\d+/.test(trimmedLine)) { // Line starts with number (verse)
      verses.push(trimmedLine);
      verseCount++;
      if (verseCount >= 3) break;
    } else if (trimmedLine && verseCount > 0) {
      // Continue with previous verse if it's not a new verse number
      if (verses.length > 0) {
        verses[verses.length - 1] += " " + trimmedLine;
      }
    }
  }
  
  const previewContent = verses.join('\n');
  const hasMore = contentLines.length > verses.length;
  
  return {
    title: fullTitle,
    content: previewContent,
    hasMore: hasMore,
    fullText: fullText
  };
}

/**
 * Get specific verse from chapter
 */
export async function getSpecificVerse(chapterIndex, verseNumber) {
  const fullText = await getChapterText(chapterIndex);
  
  if (fullText === "No text found.") {
    return "Вірш не знайдено.";
  }

  // Split into lines
  const lines = fullText.split('\n').filter(line => line.trim());
  
  // Find content start (skip title and subtitle)
  let contentStartIndex = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line.includes("Розділ")) {
      contentStartIndex = i + 1;
      // Check if next line is subtitle
      if (i + 1 < lines.length) {
        const nextLine = lines[i + 1].trim();
        if (nextLine && !/^\d+/.test(nextLine) && !nextLine.includes("Розділ")) {
          contentStartIndex = i + 2;
        }
      }
      break;
    }
  }
  
  // Find the specific verse
  const contentLines = lines.slice(contentStartIndex);
  let currentVerse = 0;
  let verseText = "";
  
  for (const line of contentLines) {
    const trimmedLine = line.trim();
    if (trimmedLine && /^\d+/.test(trimmedLine)) { // Line starts with number
      currentVerse++;
      if (currentVerse === verseNumber) {
        verseText = trimmedLine;
        break;
      }
    } else if (trimmedLine && currentVerse === verseNumber) {
      // Continue with the current verse
      verseText += " " + trimmedLine;
    }
  }
  
  return verseText || `Вірш ${verseNumber} не знайдено в цій главі.`;
}

/**
 * Get formatted chapter preview starting from specific verse
 */
export async function getChapterPreviewWithVerses(index, verseStart = 0) {
  const fullText = await getChapterText(index);
  
  if (fullText === "No text found.") {
    return { title: "", content: "No text found.", hasMore: false };
  }

  // Split into lines
  const lines = fullText.split('\n').filter(line => line.trim());
  
  // Extract title and subtitle
  let title = "";
  let subtitle = "";
  let contentStartIndex = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Look for chapter number (Розділ X)
    if (line.includes("Розділ")) {
      title = line;
      contentStartIndex = i + 1;
      
      // Check if next line is a subtitle (not a verse number)
      if (i + 1 < lines.length) {
        const nextLine = lines[i + 1].trim();
        if (nextLine && !/^\d+/.test(nextLine) && !nextLine.includes("Розділ")) {
          subtitle = nextLine;
          contentStartIndex = i + 2;
        }
      }
      break;
    } else if (i === 0 && !title) {
      // Fallback: use first line as title
      title = line;
      contentStartIndex = i + 1;
    }
  }
  
  // Combine title and subtitle
  const fullTitle = subtitle ? `${title}\n${subtitle}` : title;
  
  // Extract verses starting from verseStart
  const contentLines = lines.slice(contentStartIndex);
  const verses = [];
  let verseCount = 0;
  let currentVerseIndex = 0;
  
  for (const line of contentLines) {
    const trimmedLine = line.trim();
    if (trimmedLine && /^\d+/.test(trimmedLine)) { // Line starts with number (verse)
      if (currentVerseIndex >= verseStart) {
        verses.push(trimmedLine);
        verseCount++;
        if (verseCount >= 3) break;
      }
      currentVerseIndex++;
    } else if (trimmedLine && verseCount > 0) {
      // Continue with previous verse if it's not a new verse number
      if (verses.length > 0) {
        verses[verses.length - 1] += " " + trimmedLine;
      }
    }
  }
  
  const previewContent = verses.join('\n');
  const hasMore = currentVerseIndex > verseStart + 3;
  
  return {
    title: fullTitle,
    content: previewContent,
    hasMore: hasMore,
    fullText: fullText
  };
}

/**
 * Shortcut: get first chapter
 */
export async function getFirstChapterText() {
  return getChapterText(0);
}

/**
 * Get Table of Contents (hierarchical)
 */
export async function getTableOfContents() {
  const epub = await loadEpub();
  const zip = new AdmZip(path.join(__dirname, "book.epub"));
  const tocEntry = zip.getEntry("toc.ncx");

  if (!tocEntry) throw new Error("toc.ncx not found in EPUB");

  const tocData = tocEntry.getData().toString("utf-8");
  const parsed = await xml2js.parseStringPromise(tocData, { explicitArray: false });

  const navMap = parsed.ncx.navMap.navPoint;

  function buildTOC(points) {
    if (!points) return [];
    if (!Array.isArray(points)) points = [points];

    return points.map((p) => ({
      title: p.navLabel.text,
      subchapters: buildTOC(p.navPoint),
    }));
  }

  return buildTOC(navMap);
}

/**
 * Get total chapters (optional)
 */
export async function getTotalChapters() {
  const epub = await loadEpub();
  return epub.flow?.length || 0;
}
